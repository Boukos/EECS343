<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" lang="en-gb" dir="ltr" >
<head>
      <base href="http://www.aqualab.cs.northwestern.edu/class/334-eecs-343-project-1-xv6" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="FabiÃ¡n E. Bustamante" />
  <meta name="generator" content="Joomla! - Open Source Content Management" />
  <title>EECS343-Project-xv6-1</title>
  <link href="/templates/aqualab-classes/favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon" />
  <link rel="stylesheet" href="/media/com_attachments/css/attachments_hide.css" type="text/css" />
  <link rel="stylesheet" href="/media/com_attachments/css/attachments_list.css" type="text/css" />
  <style type="text/css">

@import url('/css/classes/classes.css');
@import url('/css/classes/jquery-ui.css');
ol.second{ list-style-type:lower-latin; }
ul{padding-top: 1.0em;}

  </style>
  <script src="/media/system/js/mootools-core.js" type="text/javascript"></script>
  <script src="/media/system/js/core.js" type="text/javascript"></script>
  <script src="/media/system/js/caption.js" type="text/javascript"></script>
  <script src="/media/system/js/mootools-more.js" type="text/javascript"></script>
  <script src="/media/com_attachments/js/attachments_refresh.js" type="text/javascript"></script>
  <script type="text/javascript">
window.addEvent('load', function() {
				new JCaption('img.caption');
			});
  </script>

    <link rel="shortcut icon" href="/templates/aqualab-classes/favicon.ico" />
    <link rel="stylesheet" href="/templates/aqualab-classes/css/classes.css" type="text/css" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
</head>
<body>


<div id="system-message-container">
</div>
<div class="item-page">









 

<style>
  .code { font-family: monospace; display: inline; font-size: 1.3em;}
</style>
<script type="text/javascript" src="/js/jquery-ui.js"></script>
<script type="text/javascript">
  jQuery(function() {jQuery( "#tabs" ).tabs();});
</script>
<h2>EECS 343 Operating Systems -- Project 1 -- ps on xv6 </h2>

<div id="tabs">
  <ul>
    <li><a href="#project">Project Description</a></li>
    <li><a href="#submission">Submission Instructions</a></li>
    <!--
    <li><a href="#ec">Extra Credit</a></li>
    <li><a href="#plan">Plan of Attack</a></li>
    <li><a href="#testing">Testing</a></li>
    <li><a href="#background">Background Info</a></li>
    <li><a href="#deliverable">Grading &amp; Deliverables</a></li>
    -->
  </ul>
  
  
  <div id="main" style="width: 100%;">
    <!------------------------------------------------>
    <div id="project">
      
      <h2>Project 1: ps -- process status -- on xv6</h2>
      
      <h3>Important Dates</h3>
      <p><b>Out:</b> Wednesday, September 21st, 2016.</p>
      <p><b>Due:</b> Friday, September 30th, 2015 (11:59 PM CDT).</p>
      <!--
      <p><strong>To submit your project (<em>ASCII text only!</em>)</strong> use the following page: <a href="https://www.cs.northwestern.edu/~aqualab/assignments/OS/submission.htm">SUBMISSIONS</a>. </p>
      -->
      <p><b>Submission:</b> Submission instructions are now posted.  Click on the tab above.</p>
      
      
      <h3>Resources</h3>
      <ul>
        <li>Some useful GDB and QEMU commands: <a href="https://pdos.csail.mit.edu/6.828/2016/labguide.html" target="_blank">https://pdos.csail.mit.edu/6.828/2016/labguide.html</a></li>
        <li>xv6 textbook: <a href="https://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf" target="_blank">https://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf</a><br/> (note that we are using a version of the code from 2012)</li>
        <li>Guide to xv6 codebase: <a href="https://pdos.csail.mit.edu/6.828/2012/xv6/xv6-rev7.pdf" target="_blank">https://pdos.csail.mit.edu/6.828/2012/xv6/xv6-rev7.pdf</a></li>
        <li>Hexadecimal converter: <a href="https://www.mathsisfun.com/binary-decimal-hexadecimal-converter.html" target="_blank">https://www.mathsisfun.com/binary-decimal-hexadecimal-converter.html</a></li>
      </ul>
      
      <h3>Project Overview</h3>
      <p>This project is composed of three parts, which you must complete in order.  Part 0 is the easiest part and simply requires you to get your development environment setup correctly.  Part 1, which is slightly more difficult, will require you to trace a <span class="code">fork</span> system call ("syscall") using GDB and answer some questions.  Part 2, which is the most challenging, will have you implement the <span class="code">ps</span> shell command along with a syscall that is required for the command to work.  Detailed instructions will be given further below, but here is a brief summary of each part.</p>
      
      <p><b>Part 0</b> (15 points)<br/>
        Must be done individually and should be completed ASAP.  This part will require you to carefully follow instructions to get your development environment setup.  Since this is an operating systems course, the projects will require you to write operating system code, which requires a fairly complex development environment.  So even though this is the easiest part of the project, it isn't <i>that</i> easy.</p>
      
      <p><b>Part 1</b> (15 points)<br/>
        Must be done individually as well.  This part also involves no coding, but it does require you to have your xv6 kernel up and running.  That is, you must complete Part 0 in order to complete Part 1.  In this part, you will use GDB to walk through the execution of the <span class="code">fork</span> system call and answer a few questions as you do.  When you are done, you will submit a text file with your answers.</p>
      
      <p><b>Part 2</b> (70 points)<br/>
        Should be done in groups of 2-3 people.  In this part, you will write some kernel code as well as a user program.  The user program you must write is the <span class="code">ps</span> shell command.  In order to write this user program, you will also have to write a new syscall for the kernel called <span class="code">getprocs</span>.  This will give you a first taste of operating system development.</p>
      
      <h3>Educational Objectives</h3>
      <p>This project aims to achieve several educational objectives:</p>
      <ul>
        <li>Every individual gets their development environment set up with a functioning xv6 kernel.</li>
        <li>Gain a thorough understanding of how new processes are created via the fork system call.</li>
        <li>Become a master at using GDB to inspect and debug code.</li>
        <li>Understand how information about each process is stored in the process table.</li>
        <li>Understand how a user program can invoke kernel code via system calls.</li>
        <li>Cut your teeth as a budding OS developer.</li>
      </ul>
      
      <h3>Part 0: Set up development environment</h3>
      <p><b>15 points</b></p>
      <p><b>To be completed individually</b></p>
      
      <p>To get your development environment setup, carefully read and follow the instructions here: <a href="http://www.aqualab.cs.northwestern.edu/class/333-eecs343-xv6" target="_blank">http://www.aqualab.cs.northwestern.edu/class/333-eecs343-xv6</a></p>
      
      <h3>Part 1: How processes are born</h3>
      <p><b>15 points</b></p>
      <p><b>To be completed individually</b></p>
      
      <p>In this part, you will use GDB to walk through the xv6 code as it creates a new process.  We will provide the GDB commands for you.  All you have to do is follow the instructions and answer the questions that we ask along the way.</p>
      
      <p>To get started, open two terminals and make sure you are in the xv6 directory in both.  In one terminal, run xv6 with remote debugging enabled by typing:</p>
      
      <p class="code">$ make qemu-nox-gdb</p>
      
      <p>In the other terminal, run GDB as a remote debugger by typing:</p>
      
      <p class="code">$ gdb kernel/kernel</p>
      
      <p>+++++++++++++++++++++++++++++++++</p>
      
      <p>This terminal (your GDB terminal) should now be connected to your xv6 terminal.  Meanwhile, in the other terminal, xv6 is currently stalling the boot-up process while it waits for you to give commands via GDB.  Tell GDB to allow execution to continue by typing:</p>
      
      <p class="code">(gdb) c</p>
      
      <p>Wait for xv6 to boot up until it reaches the shell prompt.  Then in your GDB terminal, interrupt xv6 by hitting:</p>
      
      <p class="code">control+c</p>
      
      <p>You should see GDB give the following output:</p>
      
      <p class="code">Program received signal SIGINT, Interrupt.<br/>
        The target architecture is assumed to be i386
      </p>
      
      <p><font color="blue">NOTE: Rumor has it that if you are using putty to ssh from a Windows machine into a lab machine, the <span class="code">control+c</span> command may not work to interrupt xv6.  You can work around this problem by skipping from the "+++++++" line above to the "******" line below.</font></p>
      
      <p>GDB will also print out an address and a line number of the exact spot in code that is currently being executed.  This will vary because the kernel's scheduler is looping through the process table looking for processes to execute.  You don't have to worry about that for now.  The only process we currently care about is the shell process that is sitting there, waiting for input.</p>
      
      <p>**********************************</p>
      
      <p>We want to set a breakpoint in the shell program, but GDB currently has the symbol table for the kernel loaded, so we have to tell it to load the symbol file for the shell program by typing:</p>
      
      <p class="code">(gdb) symbol-file user/sh.o</p>
      
      <p>When it asks if you want to load a new symbol table, type 'y'.  We can now set a breakpoint in the shell program by typing:</p>
      
      <p class="code">(gdb) b sh.c:160</p>
      
      <p>This command sets a breakpoint (b) in the file <span class="code">user/sh.c</span> at line 160.  Go ahead and open a text editor such as gedit or Sublime, open the file <span class="code">user/sh.c</span> and look at line 160.  Take a quick look at the while loop that this line sits within.  Now return control to xv6 by typing 'c' in your GDB terminal.</p>
      
      <p>Switch over to your xv6 terminal.  We want to run a program that will trigger the breakpoint we just set.  Let's run the echo program.  Type:</p>
      
      <p class="code">$ echo hello world</p>
      
      <p>You should see that your breakpoint has been hit.  In GDB you will see this output:</p>
      
      <p class="code">Breakpoint 1, main () at user/sh.c:160</p>
      
      <p>GDB will also print the code on line 160.  In GDB, type 'n' which should bring you to line 168.  Make sure you understand why you didn't enter the <span class="code">if</span> block on lines 161-167.  On line 168, we are about to execute a function called <span class="code">fork1()</span>.  We want to watch that function execute so set a breakpoint by typing:</p>
      
      <p class="code">(gdb) b fork1</p>
      
      <p>Then type 'c' to continue.  You are now inside the <span class="code">fork1()</span> function.  Pretty much the first thing this function does is call a function called <span class="code">fork()</span>.  Don't be fooled by how similar the name is.  <span class="code">fork()</span> is a system call and will invoke the execution of kernel code.</p>
      <br/>
      <br/>
      <p>Try to set a breakpoint in the <span class="code">fork</span> syscall by typing:</p>
      
      <p class="code">(gdb) b fork</p>
      
      <p>GDB will give the following warning:</p>
      
      <p class="code">Function "fork" not defined.<br/>
        Make breakpoint pending on future shared library load? (y or [n])</p>
      
      <p>The reason for this warning is that we currently have the symbol table for <span>sh</span> loaded, but the code for the <span class="code">fork</span> syscall is in kernel code.  Type 'y' then load the symbol table for the kernel by typing:</p>
      
      <p class="code">(gdb) symbol-file kernel/kernel</p>
      
      <p>Type 'y' again to confirm that you want to load the new symbol table.  You should see the following warnings in GDB:</p>
      
      <p class="code">
        Error in re-setting breakpoint 1: No source file named sh.c.<br/>
        Error in re-setting breakpoint 2: Function "fork1" not defined.<br/>
      </p>
      
      <p>This is telling us that our breakpoints that we previously set are no longer valid in the new symbol table.  We have to delete them to avoid any trouble:</p>
      
      <p class="code">(gdb) d 1</p><br/>
      <p class="code">(gdb) d 2</p>
      
      <p>These commands tell GDB to delete (d) breakpoints #1 and #2.</p>
      
      <p>Now we should also confirm that our <span class="code">fork</span> breakpoint was automatically set after the kernel symbol table loaded.  To get info about your current breakpoints, type:</p>
      
      <p class="code">(gdb) info b</p>
      
      <p>You should should see a list of your breakpoints (just one breakpoint in the list for now).  Make sure that it looks like this:</p>
      
      <p class="code">3       breakpoint     keep y   0x00103e3c in fork at kernel/proc.c:134</p>
      
      <p>Type 'c' in GDB and you should hit your <span class="code">fork</span> breakpoint.  Go back to your text editor, open the file kernel/proc.c, and look at line 134.  Indeed, you are inside the <span class="code">fork</span> function.  To see how we got here, let's inspect the call stack.  In GDB, type:</p>
      
      <p class="code">(gdb) bt</p>
      
      <p>On the top of the stack in spot #0 is the <span class="code">fork()</span> function we are currently sitting in.  You may have expected that this function was called directly by the <span class="code">fork1()</span> function we were looking at above, but instead, in spot #1, we see that this <span class="code">fork()</span> function was actually called by <span class="code">sys_fork()</span>, which was called by <span class="code">syscall()</span>, which was called by <span class="code">trap()</span>, which was called by <span class="code">alltraps()</span>.  These functions are evidence of the work done by the kernel "behind the curtain" whenever a user program makes a syscall.</p>
      
      <p>Now let's look more closely at the <span class="code">fork()</span> function we are still sitting in.  Read the comments above the function to get an idea of what it does.  Then read through the function code itself and try to understand how it works.</p>
      
      <p><b>Question 1:</b> What is the <i>type</i> of variable <span class="code">np</span>?</p>
      <p><b>Question 2:</b> What does <span class="code">np</span> represent?  In other words, what do the letters 'n' and 'p' stand for?</p>
      <p><b>Question 3:</b> What does the variable <span class="code">proc</span> represent?  Hint: You can find its type by looking at its declaration in <span class="code">kernel/proc.h</span>.</p>
      
      <p>If you can't answer these questions definitively right now, that's OK, we're going to step through the code.  In GDB, type 'n' to execute the line 134.  Then type:</p>
      
      <p class="code">(gdb) print np</p>
      
      <p>GDB outputs the type of the variable and the value.  The type is your answer to question 1 above.  The value is actually an address.  Since <span class="code">np</span> is a pointer, it stores the address of an object that it is pointing to.  This leads to our next question...</p>
      
      <p><b>Question 4:</b> What is the address of the object that <span class="code">np</span> is pointing to?</p>
      
      <p>Now have a look at the object itself by typing:</p>
      
      <p class="code">(gdb) print *np</p>
      
      <p>We'll actually want to keep an eye on this object because its attributes will gradually be initialized throughout the <span class="code">fork</span> syscall.  We can tell GDB to display this object automatically by typing:</p>
      
      <p class="code">(gdb) display *np</p>
      
      <p>Then type 'n' to execute the next line of code and notice that GDB automatically displays the <span class="code">np</span> object again.  Look at the line of code that just executed (line 138), then look at which attributes of the <span class="code">np</span> object have changed as a result.</p>
      
      <p>Continue stepping through the <span class="code">fork</span> function watching as the values within the np object continue to change.  Make sure you stop before the function returns on line 159.</p>
      
      <p><b>Question 5:</b> What is the <span class="code">name</span> of the child process that was created?  Note: Although you may not believe your own answer at first, you can trust that GDB is not lying to you.  The child process will later be renamed and repurposed.</p>
      
      <p>Now take a look at the value of <span class="code">pid</span>, which the <span class="code">fork</span> syscall is about to return, by typing:</p>
      
      <p class="code">(gdb) print pid</p>
      
      <p><b>Question 6:</b> What is the value of <span class="code">pid</span>?</p>
      
      <p><b>Question 7:</b> In which process, the parent or the child, will this value be returned?</p>
      
      <h3>Part 2: Implementing the ps command</h3>
      <p><b>70 points</b></p>
      <p><b>To be completed in groups of 2-3</b></p>
      
      <p>Part 2 requires you to implement the <span class="code">ps</span> shell command.  When you are done with this project, you will be able to get info about the currently running processes on xv6 by typing:</p>
      
      <p class="code">$ ps</p>
      
      <p>To get an idea of what the <span class="code">ps</span> command is supposed to do, open a regular Linux shell (e.g. on a lab machine) and type <span class="code">ps</span>.  You will see some info about the currently running processes.  To see even more info, run <span class="code">ps</span> again with the <span class="code">-u</span> flag.  You can read more about the <span class="code">ps</span> command <a href="https://en.wikipedia.org/wiki/Ps_(Unix)" target="_blank">on wikipedia</a> or by doing a google search.</p>
      
      <h4>Part 2a: Writing the getprocs syscall</h4>
      
      <p>Before you can implement the <span class="code">ps</span> command, you will need to write a new syscall to get information about the current processes from the kernel.  Here is the function signature for the syscall you will write:</p>
      
      <p class="code">int getprocs(struct ProcessInfo processInfoTable[]);</p>
      
      <p>You'll have to dig through the codebase to find where exactly this function signature should be added.</p>
      
      <p>This syscall, once implemented, will return the number of current processes in the kernel--that is, the number of entries in the kernel's process table that are in any state other than <span class="code">UNUSED</span>.  If the syscall cannot be completed for any reason, it shall return -1.</p>
      
      <p>In Part 2b down below, we'll worry about populating the <span class="code">ProcessInfo</span> table, but for now, we just need to add a struct definition so that your code will compile.  Add a new file <span class="code">include/ProcessInfo.h</span> with this definition of struct ProcessInfo:</p>
      
      <p class="code">
        struct ProcessInfo {<br/>
        &nbsp;&nbsp;int pid;   // process id<br/>
        &nbsp;&nbsp;int ppid;  // parent pid<br/>
        &nbsp;&nbsp;int state; // state<br/>
        &nbsp;&nbsp;uint sz;   // size in bytes<br/>
        &nbsp;&nbsp;char name[16];  // name of process<br/>
        };<br/>
      </p>
      
      <p>Now you are ready to begin implementing your new syscall.  Again, you'll have to search the codebase to see how and where other syscalls are implemented, then follow suit.</p>
      
      <p>In order to help you search the code, you'll probably want to use a text editor that allows you to search multiple files at once so that you can find every occurence of your search term.  This will help you figure out all the files that you have to touch in order to implement a new syscall.</p>
      
      <p>Once you have your syscall implemented, see if your code compiles by simply typing <span class="code">make</span> in the xv6 directory.  Once your code is compiling, you can try to run xv6 by typing <span class="code">make qemu-nox</span>.</p>
      
      <p>Finally you can do a sanity check to see if your syscall is working by writing a simple user program that uses it.  Create a new file <span class="code">user/ps.c</span> that invokes your new syscall and outputs the result using <span class="code">printf</span>.  In order to run this new user program within xv6, you'll have to make a small modification to <span class="code">user/makefile.mk</span>.</p>
      
      <h4>Part 2b: Writing the ps user program</h4>
      
      <p>In the final part of this project, you'll expand your <span class="code">user/ps.c</span> program to actually print out information about each process similar to the Linux <span class="code">ps</span> command.  Your command won't print out the header line, but for each process it will print out a line containing the following info:</p>
      
      <p>process id, parent process id, state, size, name</p>
      
      <p>Here are some additional requirements:</p>
      <ul>
        <li>Each process should be on a new line.</li>
        <li>Each piece of info on a line should be separated by two spaces.</li>
        <li>The parent process id of the first process is meaningless.  For this value, print -1.</li>
        <li>The state must be printed as human-readable text in all caps (not an integer value).</li>
      </ul>
      
      <p>Here is an example of what your output will approximately look like when you run your <span class="code">ps</span> command from the xv6 shell prompt:</p>
      
      <p class="code">
        $ ps<br/>               1&nbsp;&nbsp;-1&nbsp;&nbsp;SLEEPING&nbsp;&nbsp;8192&nbsp;&nbsp;init<br/>   2&nbsp;&nbsp;1&nbsp;&nbsp;SLEEPING&nbsp;&nbsp;12288&nbsp;&nbsp;sh<br/>   3&nbsp;&nbsp;2&nbsp;&nbsp;RUNNING&nbsp;&nbsp;8192&nbsp;&nbsp;ps<br/>
      </p>
      
      <p>In order to accomplish this, you'll have to expand your <span class="code">getprocs</span> syscall to actually populate the <span class="code">processInfoTable[]</span> with information that it gathers from the kernel's <span class="code">ptable</span> (process table).  You'll be working in pretty much all the same files as in Part 2a, just adding functionality.</p>
      
      <p>One tricky part is figuring out how a syscall gets the arguments that were passed to it (e.g. how your kernel code will get a hold of the pointer to the <span class="code">processInfoTable</span>).  Fortunately, there are functions that are provided to help with this.  You should be able to find them by looking at some of the other syscalls.</p>
      
      <p>Once you are done with your modifications to your <span class="code">getprocs</span> syscall and your <span class="code">ps.c</span> program, you can test everything by running xv6 and typing <span class="code">ps</span> at the prompt.  For more interesting outputs you can run a shell within a shell (within a shell...) by typing <span class="code">sh</span> at the xv6 prompt.  And you can kill processes by typing <span class="code">kill</span> followed by the pid.</p>
      
    </div> <!-- project description -->
    
    <div id="submission">
      
      <h2>Submission Instructions</h2>
            
      <p>Please read all the instructions and follow them carefully.  Submissions for this project will be done through our submissions page here: <a href="https://www.cs.northwestern.edu/~aqualab/assignments/OS/submission.htm" target="_blank">https://www.cs.northwestern.edu/~aqualab/assignments/OS/submission.htm</a>  If you run into problems with the submission site, please see the troubleshooting insructions below.</p>
      
      <p><b>Part 0:</b> Nothing to submit.</p>
      
      <p><b>Part 1:</b> To be submitted individually by each student.  Follow these steps:</p>
      <ol>
        <li>Download the template file here: <a href="http://www.aqualab.cs.northwestern.edu/component/attachments/download/702"target="_blank">answer template</a></li>
        <li>Open the template file and read the instructions.</li>
        <li>Insert your answers in the designated spots between square brackets and save your file.</li>
        <li>Go to the <a href="https://www.cs.northwestern.edu/~aqualab/assignments/OS/submission.htm" target="_blank">submission site</a>, select "Project 1, Part 1" and upload your file.</li>
      </ol>
      
      <p><b>Part 2:</b> Please choose one group member to perform the submission.  Here are the instructions:</p>
      <ol>
        <li>In your <span class="code">xv6</span> directory, create a new file called <span class="code">team.txt</span>.  Type the netid of each team member on a separate line.  If your group has 3 members, your <span class="code">team.txt</span> file should have 3 lines.  If for some crazy reason your worked alone, your <span class="code">team.txt</span> file should have only 1 line, with only your netid.</li>
        <li>In your xv6 directory, type:<br/>
          <span class="code">make clean</span><br/>
          This removes all the .o and executable files, so that you will only submit your source code.
        </li>
        <li>cd to one directory above your xv6 directory.  Then create a .tar.gz of your xv6 directory by typing:<br/>
          <span class="code">tar -zcvf xv6-project1.tar.gz xv6</span><br/></li>
        <li>Go to the <a href="https://www.cs.northwestern.edu/~aqualab/assignments/OS/submission.htm" target="_blank">submission site</a>, select "Project 1, Part 2" and upload your xv6-project1.tar.gz file.</li>
      </ol>
      
      <p>NOTE: If you submit your code before the deadline and then realize you need to change something, you can re-submit your code as long as it is the same group member who performs the submission.  Your last submission will be the one that gets graded.  However, if multiple group members submit multiple different versions of the code, well, I really have no idea what will happen, but it might not be pretty.  So please put one group member in charge of submitting Part 2.</p>
      
      <p><b>Troubleshooting Submissions:</b> If the submissions site won't load for you, please try the following steps.</p>
      <ul>
        <li>If you see a certificate warning, you'll have to add an exception for the site.  Sorry.</li>
        <li>If the page still fails to load, try using a different browser.</li>
        <li>If the page still fails to load, try using yet another different browser.  NOTE: Chrome and Firefox can be downloaded for free.</li>
        <li>If you are on Windows, try going to a lab machine or using a friend's Mac.</li>
        <li>If all else fails, you can email the submission to one of the TAs.</li>
      </ul>
      
      
    </div> <!-- submission -->
    
  </div> <!-- main -->
</div> <!-- tabs --><div class="attachmentsContainer">

<div class="attachmentsList" id="attachmentsList_com_content_article_334">
<table>
<caption>Attachments:</caption>
<tbody>
<tr class="odd"><td class="at_filename"><a class="at_icon" href="/component/attachments/download/702" title="Download this file (answers.txt)"><img src="/media/com_attachments/images/file_icons/text.gif" alt="Download this file (answers.txt)"  /></a><a class="at_url" href="/component/attachments/download/702" title="Download this file (answers.txt)">answers.txt</a></td></tr>
</tbody></table>
</div>

</div>
	
</div>




<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> </script>
<script type="text/javascript"> _uacct = "UA-2595418-1"; urchinTracker(); </script>

</body>
</html>
